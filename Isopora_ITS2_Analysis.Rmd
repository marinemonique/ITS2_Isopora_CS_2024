---
title: "Isopora ITS2 Analysis"
author: "Monique White"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Libraries
```{r, warning = FALSE, echo = FALSE, message=FALSE}
library(ggsci)
library(tidyverse)
library(dplyr)
library(forcats)
library(reshape2)
library(tibble)
library(sangerseqR)
library(DECIPHER)
library(Biostrings)
library(phangorn)
library(ape)
library(ggplot2)
library(ggtree)
library(patchwork)
library(bioseq)
library(kmer)
library(GUniFrac)
library(seqinr)
library(vegan)
library(corrplot)
library(ggrepel)

library(ggmsa)
library(dendextend)
library(usedist)
```


```{r}
seqs_iso <- read_tsv("seqs.abs.Isopora.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))

seqs_iso
```

# Load metadata
Note the metadata requires the imput of the CoralSea2024_Metadata.xlsx. you need to change the path for where the file lives on your in individual computer.

```{r}
library(readxl)
CoralSea2024_Metadata <- read_excel("~/AIMS@JCU/CoralSea2024_Metadata.xlsx")

meta_iso <- CoralSea2024_Metadata %>% 
  rename("VialID" = "sample_name",
         "Depth (m)" = "Depth")

meta_iso <- meta_iso %>% 
  select(sample_name, Reference, Reef, Site,Date, Bag, Species, Depth, `Bleach score`, Vial, Year) %>% 
  filter(Species == "Isopora",
         Year != "20")
meta_iso
# Assume your metadata is in a dataframe called meta
meta_iso <- meta_iso %>%
  mutate(Region = if_else(Reef %in% c("Middleton", "Elizabeth"), 
                          "LordHowe", 
                          "CoralSea"))
meta_iso
```

# Read in environmental data and combine
```{r}
enviro <- read.csv("~/AIMS@JCU/enviro.meta.csv") 

enviro <- enviro |> 
  rename(POI_ID = "Reef")

meta_iso <- meta_iso %>% left_join(enviro)
```


```{r}
load("~/AIMS@JCU/CoralSeaSymbioants/ITS2_Isopora_CS_2024/Isopora/ind_coords_iso.RData")

ind_coords_iso <- ind_coords_iso %>% mutate(HostCluster = case_when(
  Axis1 < -30 ~ "IC1", 
Axis1 > -30 & Axis1 <0 & Axis2 < 20 ~ "IC1b",
Axis1 > -30 & Axis1 <0 & Axis2 > 20  ~ "IC1c",
Axis1 < 20 & Axis1> 0 ~ "IC2",
Axis1 > 20 ~ "IC3",
TRUE ~ NA_character_  # anything that doesn't match the above
  ))

    #Axis1 < 0 & Axis2 < 0 ~ "IC1",
    #Axis1 < -30 ~ "IC1", #depends on Magenas feedback
    #Axis1 > 0 & Axis2 > 25 ~ "IC2",
    #Axis1 > 20 & Axis2 < 0 ~ "IC3",
    #TRUE ~ NA_character_  # anything that doesn't match the above

ind_coords_iso <- ind_coords_iso %>% dplyr::rename(sample_name = SampleID) %>% 
  dplyr::select(Axis1, Axis2, Axis3, sample_name, HostCluster)

meta_iso <- meta_iso %>% left_join(ind_coords_iso) %>% 
  na.omit()
```


### Load Custom Functions
```{r}
read_fasta_df <- function (file = "") {
  fasta <- readLines(file)
  ind <- grep(">", fasta)
  s <- data.frame(ind = ind, from = ind + 1, to = c((ind - 
    1)[-1], length(fasta)))
  seqs <- rep(NA, length(ind))
  for (i in 1:length(ind)) {
    seqs[i] <- paste(fasta[s$from[i]:s$to[i]], collapse = "")
  }
  tib <- tibble(label = gsub(">", "", fasta[ind]), sequence = seqs)
  return(tib)
}

write_fasta_df <- function (data, filename) 
{
    fastaLines = c()
    for (rowNum in 1:nrow(data)) {
        fastaLines = c(fastaLines, as.character(paste(">", 
            data[rowNum, "label"], sep = "")))
        fastaLines = c(fastaLines, as.character(data[rowNum, 
            "sequence"]))
    }
    fileConn <- file(filename)
    writeLines(fastaLines, fileConn)
    close(fileConn)
}

dna_to_DNAbin <- function (dna){
  DNAbin <- as_DNAbin(dna)
  names(DNAbin) <- names(dna)
  return(DNAbin)
}
dna_to_DNAStringset <- function(x) 
{
    bioseq:::check_dna(x)
    DNAstr <- DNAStringSet(paste(x))
    names(DNAstr) <- names(x)
    return(DNAstr)
}

DNAStringSet_to_dna <- function(x){
    x_dna <- as_dna(paste(x))
    names(x_dna) <- names(x)
    res <- tibble(label = names(x), sequence = x_dna)
    return(res)
}

# Convert DNAstringset to DNAbin
DNAStringSet_to_DNAbin <- function(DNAStringSet){
  DNAbin <- as.DNAbin(DNAStringSet)
  return(DNAbin)
}

# https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2315-y
palette <- c("A" = "#46ff2d", 
             "G" = "#ffae01", 
             "C" = "#f24641", 
             "T" = "#4294fa", 
             "K" = "#8b4816",
             "M" = "#83831f",
             "R" = "#ffff81",
             "S" = "#ff9d80",
             "Y" = "#e381f2",
             "W" = "#80fff2",
             "V" = "#fde4b8",
             "B" = "#f9c1bf",
             "H" = "#c0d9f9",
             "D" = "#c7ffba",
             "U" = "#8989fb",
             "N" = "black", 
             "-" = "white",
             "+" = "White")


pal_df <- data.frame(names = names(palette), col = palette)
```


### Combining sequence/metadata 
```{r}

# Convert to long format
seqs_long <- seqs_iso %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta_iso)

seqs_long <- seqs_long %>%  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_")) %>%
  filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C"))

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check <- seqs_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check %>%
  filter(total > 1500)

non_keep <- san_check %>% 
  filter(total < 1500)

#we filter out 2 samples with less than A142 and A191

# Filter out the failed samples
seqs_long <- seqs_long %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n <- length(levels(seqs_long$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long$name)

# Read in the profile data
profiles_raw <- read_tsv("profiles.abs.Isopora.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1`:`F4q`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`F4q`)

#Convert to long format 
profiles_long <- profiles_raw %>%
  pivot_longer(`A1`:`F4q`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% 
  filter(sample_name %in% seqs_long$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta_iso) %>% 
  filter(str_starts(name, "p_C"))

# What is the total number of profile-related sequences in each sample?
profiles_sum <- profiles_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual <- left_join(profiles_sum, san_check, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta_iso)

# Combine the profiles and non-profile sequences
profile_data <- rbind(profiles_long, residual) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Create palette for profiles (this is a darker palette)
n <- length(levels(profile_data$name))
profile_pal = rainbow(n, s=.6, v=.6)[sample(1:n,n, replace = FALSE)]
names(profile_pal) <- levels(profile_data$name)

# Merge the palettes and replace the non-profile sequences with grey
all_pal <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data <- rbind(seqs_long, profile_data) 
# had to update the seqs_long to seqs_long_c - assume thats what you wanted?

dplyr::setdiff(names(profile_data), names(seqs_long)) # the difference is the relative value column, but that was present historically so I am not sure why the all_data worked then but not now that the environment data is added
#need to work out why my profiles_data has 51 variables, but the seqs_long only has 50.


```


```{r}
# How many samples per species?
all_data %>%
  distinct(sample_name, Reef) %>%
  group_by(Reef) %>% 
  summarise(total_samples = n())

study_total <- all_data %>% 
   filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  summarise(total_seqs = sum(value)) %>%
  pull(total_seqs)

#9382894 sequences in isopora dataset
```


#By symbiont genus
Please note I was a bit confused by some of the calculations here, so I have hashed them out.
```{r}
all_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C")) %>% 
  summarise(sum = sum(value))
# 8424777	

## not sure this line(X / study_total) * 100 # X Cladocopium proportion of all data.

#Total number of Symbiodinium
all_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "A" | str_detect(name, "_A")) %>% 
  summarise(sum = sum(value)) 
# 10476			total seqs
## Not sure about this calculation (X	 / study_total) * 100 # X Symbiodium


# Total number of Durusdinium sequences
all_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "D" | str_detect(name, "_D")) %>% 
  summarise(sum = sum(value)) 
# 947257	 total reads
```


```{r}
library(tidyverse)

#total type profiles across Pocilloporidae 
all_data %>%
  filter(str_detect(name, "p_")) %>%    #profiles start with p_
  group_by(name) %>%
  dplyr:: count() %>%
  dplyr:: arrange(desc(n)) %>%
  ungroup() %>%
  mutate(prop = n/sum(n)) %>%
  mutate(cumulative_sum = cumsum(prop)) %>% 
  print(n=50) #to get a list of the type profiles in isopora

```


Not sure this line works, not quite sure what I am meant to be doing here though.

```{r}
all_data %>% 
  filter(str_detect(name, "p_")) %>%
  group_by(sample_name) %>% 
  summarise(n = n()) 
 #filter(n == 1)     #150 samples have 1 type profile
 #filter(n == 2)     #23 samples have 2 type profiles 
#filter(n == 3)     #7 samples have 3 profiles 
```

```{r}
all_data %>% 
    filter(str_detect(name, c("p_"))) %>% 
    filter(str_detect(name, c("p_C3k|p_C3"))) %>% 
  summarise(mean = mean(value_rel))      #for relative proportion

#Either C3k or C3 were found as dominant seq in 75.0% of corals sampled 
```


```{r}
#filter out non-profile sequences
seq_data <- all_data %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
```

#2.1 UPGMA tree
Not sure when seq_data was made in the Acropora analysis?
```{r}
fasta_iso <- read_fasta_df("seqs.isopora.fasta") %>% 
   filter(label %in% seqs_long$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()
```

```{r}
#creating the tree
kdist_iso <- fasta_iso %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()
```

```{r}
k_tree_iso <- kdist_iso %>% phangorn::upgma()

k_tree_iso
```

Phylogenetic tree with only Cladicopium has 398 tips and 397 internal nodes.
```{r}
seqs_wide_iso <- seq_data %>%
  dplyr::select(sample_name, name, value) %>%
    filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C")) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") 
  

head(seqs_wide_iso)
```

```{r}
k_unidist_iso <- GUniFrac(seqs_wide_iso, k_tree_iso)   #GUniFrac calculates all the distances 
k_unidist_iso <- k_unidist_iso$unifracs


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_iso <- k_unidist_iso[, , "d_0.5"]   
dist_iso <- as.dist(du_iso, diag = FALSE)

# Cluster the samples
hclust_samps_iso <- upgma(du_iso)

# Make the sample tree
tree_iso <- ggtree(hclust_samps_iso, size = 0.2) +
  theme(aspect.ratio = 0.3) + layout_dendrogram()

# Get a sample order from ggtree
iso_sample_order <- tree_iso$data %>% filter(isTip == "TRUE") %>%
  arrange(y) %>%
  pull(label)

# Start plotting the composition data
plot_df_iso <- all_data %>%
  mutate(sample_name = fct_relevel(sample_name, iso_sample_order))

theme_set(theme_bw())


# find the likely distinguishing seqs in here
test_df <- seq_data %>%
   group_by(name) %>%
   summarise(mean = mean(value_rel), n = n()) %>%
   arrange(desc(n), desc(mean))

# colour them black to check
 test_pal <- all_pal
# test_pal['C21ab'] <- "#000000" 
```

## Fig 2B
```{r}
bar_uni_iso <- 
ggplot(plot_df_iso, aes(sample_name, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = all_pal, breaks = levels(profile_data$name)) +
scale_colour_manual(values = all_pal, breaks = levels(profile_data$name)) +
geom_hline(yintercept = 1, size = 1) +
guides(fill=guide_legend(ncol=2))


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef. 

tree_iso / bar_uni_iso
```


```{r}
# Create reef strip
reef_strip <- ggplot(plot_df_iso, aes(x = sample_name, y = 1, fill = Region)) +
  geom_tile() +
  theme_void() +
  theme(legend.position = "top") 

# Now combine the reef strip and your barplot
combined_plot <- reef_strip / bar_uni_iso + plot_layout(heights = c(0.1, 1))

# Display it
combined_plot
```

**Need to ask Magena why some of these are NA... I am not sure that she had that on her code**

###4.1.3 iso Reef PCoA

It is unclear to me how we determine the outlier samples here
```{r}

reef_order <- c("Willis", "Madgelaine", "Herald", "Diamond", "Coringa",
  "Marion", "Mellish", "Frederick", "Saumarez", "Kenn",
  "Wreck", "Cato", "GBR", "Elizabeth", "Middleton")

pcoa_iso <- cmdscale(dist_iso, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

ordiplot(pcoa_iso, display = 'sites', type = 'text')
barplot (pcoa_iso$eig, names = paste ('PCoA', 1:187),  ylab = 'eigenvalues')

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.iso <- data.frame(pcoa_iso$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta_iso)

isoPCA <- MDSxy.iso %>%
  filter(Reef != "NA") %>% 
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) 
isoPCA
```

```{r}
 MDSxy.iso %>%
  filter(Reef != "NA") %>% 
  ggplot(aes(X1, X2, fill = Region)) + 
  geom_point(alpha = 1, shape = 21, size = 3)
```


```{r}
 MDSxy.iso %>%
  filter(Reef != "NA") %>% 
  ggplot(aes(X1, X2, fill = HostCluster)) + 
  geom_point(alpha = 1, shape = 21, size = 3)
```

```{r}
str(profiles_long)
```

```{r}
library(dplyr)
library(ggplot2)
library(forcats)


# Normalize to relative abundance per sample
symbiont_long <- profiles_long %>%
  group_by(sample_name) %>%
  mutate(rel_abund = value / sum(value)) %>%
  ungroup()

symbiont_long <- symbiont_long %>% na.omit()

# Plot: faceted by HostCluster only
sym_bar <- ggplot(symbiont_long, aes(x = sample_name, y = rel_abund, fill = name)) +
  geom_bar(stat = "identity", width = 0.9) +
  facet_wrap(~HostCluster, scales = "free_x", nrow = 2) +
  theme_bw() +
  labs(
    x = "Sample",
    y = "Relative Abundance",
    fill = "Symbiont Profile",
    title = "Symbiont Community Composition by Host Cluster"
  ) +
theme(
  axis.text.x = element_text(angle = 90, hjust = 1, size = 6),
  strip.text = element_text(size = 10),
  legend.position = "bottom",
  panel.spacing = unit(1, "lines"),
  legend.text = element_text(size = 5),
  legend.key.size = unit(0.3, "cm"),
  legend.spacing.x = unit(0.2, "cm"),
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0)
)

sym_bar
```


```{r}
# Plot: faceted by HostCluster only
sym_bar <- ggplot(symbiont_long, aes(x = sample_name, y = rel_abund, fill = name)) +
  geom_bar(stat = "identity", width = 0.9) +
  facet_wrap(~Region, scales = "free_x", nrow = 1) +
  theme_bw() +
  labs(
    x = "Sample",
    y = "Relative Abundance",
    fill = "Symbiont Profile",
    title = "Symbiont Community Composition by Region"
  ) +
theme(
  axis.text.x = element_text(angle = 90, hjust = 1, size = 6),
  strip.text = element_text(size = 10),
  legend.position = "bottom",
  panel.spacing = unit(1, "lines"),
  legend.text = element_text(size = 5),
  legend.key.size = unit(0.3, "cm"),
  legend.spacing.x = unit(0.2, "cm"),
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0)
)

sym_bar
```



```{r}
enviro <- read.csv("enviro.meta.csv") %>% 
  dplyr::select(-X) %>% 
  dplyr::select(-X.1)

meta_iso <- meta_iso %>% left_join(enviro)
```


```{r}
library(vegan)

common_samples <- intersect(rownames(du_iso), meta_iso$sample_name)

# 2. Subset community matrix to common samples (rows)
du_iso_sub <- du_iso[common_samples, , drop = FALSE]

# 3. Subset metadata to common samples and reorder to match community matrix
meta_iso_sub <- meta_iso %>%
  filter(sample_name %in% common_samples) %>%
  arrange(match(sample_name, common_samples))

# Check dimensions
dim(du_iso_sub)
dim(meta_iso_sub)
```


```{r}
ord_iso <- dbrda(du_iso_sub ~ Depth + HostCluster + VarSST + MeanDHW + MeanSST, data = meta_iso_sub)



backstep_iso <- ordistep(ord_iso, direction = "backward", permutations = 999)
anova(backstep_iso, by = 'margin')
summary(backstep_iso)

R2adj <- RsquareAdj(backstep_iso)$adj.r.squared
R2adj 

varp <- varpart(du_iso_sub, ~HostCluster, ~VarSST, ~MeanDHW, data = meta_iso_sub)
plot(varp, digits = 2, Xnames = c("HostCluster", "VarSST", "MeanDHW"), bg = c("navy", "tomato", "green"))
```

```{r}
plot(cap_model, scaling = 2)
```



#Creating a subset procrustes
```{r}
filtered_names <- MDSxy.iso %>% 
  distinct(sample_name) %>% 
  pull(sample_name)
```



#Procrustes
```{r}
load("ind_coords_iso.RData")

iso_seqs_host <- ind_coords_iso #%>% 
  #mutate("sample_name" = VialID)

filtered_names <- MDSxy.iso %>% 
  distinct(sample_name) %>% 
  pull(sample_name)

seq_data_filtered <- seq_data %>%
  filter(sample_name %in% filtered_names)

#here is the subset with the data that matches the host data
shared_seqs_iso <- inner_join(iso_seqs_host, seq_data_filtered, by = "sample_name")

shared_seqs_iso %>% 
  distinct(sample_name) %>% 
  nrow()
 #should be 187 in the symbiont

shared_seqs_iso <- shared_seqs_iso %>% 
  select(sample_name)
```


```{r}
 load("iso_gen.RData") #load host data

library(adegenet) #install required package
library(poppr)


# Check your individual names in iso_gen
ind_names_host <- indNames(iso_gen)

# Check the sample names you want to keep
sample_names <- shared_seqs_iso$sample_name

# Subset the genind object to retain only matching individuals
iso_gen_subset <- iso_gen[ind_names_host %in% shared_seqs_iso$sample_name, ]

length(indNames(iso_gen))          # Before 180
length(indNames(iso_gen_subset))   # After 177

#Compute the pairwise distances between multivariate observations; used on raw allele frequencies.
host_shared_dist <- dist(iso_gen_subset, method = "euclidean") #calculate euclidean distance 

# convert the distance matrix to a dist object
host_dist_matrix <- as.dist(host_shared_dist)

#Create a matrix with only common sample names for symbiont
seqs_wide_symbiont <- seq_data %>%
  select(sample_name, name, value) %>%
    filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C")) %>% 
  filter(sample_name %in% shared_seqs_iso$sample_name) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") #187 samples


du_iso <- k_unidist_iso[, , "d_0.5"]   
dist_iso_symbiont <- as.dist(du_iso, diag = FALSE)
```

# Symbiont Tree 
```{r}
#convert host (H) and symbiont (P) distance trees as data matrices
H.dist <- host_dist_matrix %>% as.matrix()
P.dist <- dist_iso_symbiont %>% as.matrix() 
```

```{r}
#must have same number of dimensions 
dim(H.dist)
dim(P.dist) 

# Subset to only the samples that are in both datasets
intersect_samples <- intersect(rownames(H.dist), rownames(P.dist))
intersect_samples_col <- intersect(colnames(H.dist), colnames(P.dist)) # The host data set had 177, and the symbioant had 187
P.dist_intersect <- P.dist[intersect_samples, intersect_samples_col]
H.dist_intersect <- H.dist[intersect_samples, intersect_samples_col ]

# Subset to only the samples that are in both datasets
intersect_samples <- intersect(rownames(H.dist_intersect), rownames(P.dist_intersect))
P.dist <- P.dist_intersect
H.dist <- H.dist_intersect

#recheck dimensions - all good 
dim(P.dist)
dim(H.dist)
```

### Perform Paco analysis

```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

paco.iso <- procrustes(H.dist, P.dist, symmetric = FALSE)
summary(paco.iso)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#statistics check for residuals 
#paco error chart 
plot(paco.iso, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.iso, kind = 2, type = "text")
```

Call:
procrustes(X = H.dist, Y = P.dist, symmetric = FALSE) 

Number of objects: 176    Number of dimensions: 176 

Procrustes sum of squares:  
  3385946 
Procrustes root mean squared error: 
 138.7023 
Quantiles of Procrustes errors:
      Min        1Q    Median        3Q       Max 
 74.55555 105.16398 126.53689 155.95953 352.93210


### isopora procrustes plot

```{r}
#transfer PC coords into dataframe for plotting  
hp.df.iso <- data.frame(rda1=paco.iso$Yrot[,1],
rda2=paco.iso$Yrot[,2],xrda1=paco.iso$X[,1],
xrda2=paco.iso$X[,2]) %>% 
  tibble::rownames_to_column(var = "Vial") 


#filter metadata to just reef
meta.reef <- meta_iso %>% 
  select(sample_name, Reef) %>% 
  rename(sample_name = "Vial")

#left join the metadata to get reef into the dataframe 
hp.df.iso2 <- hp.df.iso %>% left_join(meta.reef)


hp.df.iso2$Reef <- factor(hp.df.iso2$Reef, levels = reef_order)

#create plot 
procrust.iso <- ggplot(hp.df.iso2) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 

procrust.iso

#save(procrust.iso, file = "procrust.iso.RData")
```



### Test significance 

```{r}
#testing significance 
protest(X = H.dist, Y = P.dist, scores = "sites", permutations = 999)
```






### Combining sequence/metadata 
```{r eval = FALSE, echo=FALSE}
# Convert to long format
seqs_long <- seqs_iso %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta_iso)
```



### Filter by sumbioant genus

## Symbiodinium
```{r eval = FALSE, echo=FALSE}
seqs_long_A <- seqs_long %>% 
  filter(str_sub(name, 1, 1) == "A" | str_detect(name, "_A"))
```

##Cladicopium

```{r eval = FALSE, echo=FALSE}
seqs_long_C <- seqs_long %>% 
  filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C"))
```

## Durusdinium
```{r eval = FALSE, echo=FALSE}
seqs_long_D <- seqs_long %>% 
  filter(str_sub(name, 1, 1) == "D" | str_detect(name, "_D"))
```


```{r eval = FALSE, echo=FALSE}
san_check_D <- seqs_long_D %>% 
  group_by(sample_name) %>%
  summarise(total = sum(value))

#List of samples that have sufficient depth
keepers_ss_D <- san_check_D%>%
  filter(total > 1500) #from 39 to 21

# Filter out the failed samples
seqs_long_D <- seqs_long_D %>%
  filter(sample_name %in% keepers_ss_D$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor
```

```{r eval = FALSE, echo=FALSE}
fasta_iso_D <- read_fasta_df("seqs.isopora.fasta") %>% 
   filter(label %in% seqs_long_D$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()
```



```{r eval = FALSE, echo=FALSE}
#creating the tree
kdist_iso_D <- fasta_iso_D %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()
```

```{r eval = FALSE, echo=FALSE}
k_tree_iso_D <- kdist_iso_D %>% phangorn::upgma()

k_tree_iso_D

#save(k_tree_iso_symbioant, file = "kdist_iso_symbioant.RData")
load("~/AIMS@JCU/CoralSeaSymbioants/ITS2_Isopora_CS_2024/kdist_iso_symbioant.RData")
```
```{r eval = FALSE, echo=FALSE}
#filter out non-profile sequences
seq_data <- all_data %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
```

```{r eval = FALSE, echo=FALSE}
seqs_wide_iso_symbioant <- seq_data %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

head(seqs_wide_iso_symbioant)
save(seqs_wide_symbioant, file =  "seqs_wide_symbioant.RData")
```

```{r eval = FALSE, echo=FALSE}
k_unidist_iso_D <- GUniFrac(seqs_wide_iso_symbioant, k_tree_iso_symbioant)   #GUniFrac calculates all the distances 
k_unidist_iso_symbioant <- k_unidist_iso_symbioant$unifracs


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_iso_symbioant <- k_unidist_iso_symbioant[, , "d_0.5"]   
dist_iso_symbioant <- as.dist(du_iso_symbioant, diag = FALSE)

# Cluster the samples
hclust_samps_iso_symbioant <- upgma(du_iso_symbioant)

# Make the sample tree
tree_iso_symbioant <- ggtree(hclust_samps_iso_symbioant, size = 0.2) +
  theme(aspect.ratio = 0.3) + layout_dendrogram()

# Get a sample order from ggtree
iso_sample_order <- tree_iso_symbioant$data %>% filter(isTip == "TRUE") %>%
  arrange(y) %>%
  pull(label)

# Start plotting the composition data
plot_df_iso_symbioant <- all_data %>%
  mutate(sample_name = fct_relevel(sample_name, iso_sample_order))

theme_set(theme_bw())


# find the likely distinguishing seqs in here
test_df <- seq_data %>%
   group_by(name) %>%
   summarise(mean = mean(value_rel), n = n()) %>%
   arrange(desc(n), desc(mean))

# colour them black to check
 test_pal <- all_pal
# test_pal['C21ab'] <- "#000000" 
```

## Fig 2B
```{r eval = FALSE, echo=FALSE}
bar_uni_iso_symbioant <- 
ggplot(plot_df_iso_symbioant, aes(sample_name, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = all_pal, breaks = levels(profile_data$name)) +
scale_colour_manual(values = all_pal, breaks = levels(profile_data$name)) +
geom_hline(yintercept = 1, size = 1) +
guides(fill=guide_legend(ncol=2))


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef. 

tree_iso_symbioant / bar_uni_iso_symbioant
```


```{r eval = FALSE, echo=FALSE}
# Create reef strip
reef_strip <- ggplot(plot_df_iso_symbioant, aes(x = sample_name, y = 1, fill = Reef)) +
  geom_tile() +
  theme_void() +
  theme(legend.position = "top") #+
 # scale_fill_brewer(palette = "Set2")  # or use your own palette

# Now combine the reef strip and your barplot
combined_plot <- reef_strip / bar_uni_iso_symbioant + plot_layout(heights = c(0.1, 1))

# Display it
combined_plot
```


###4.1.3 iso Reef PCoA

It is unclear to me how we determine the outlier samples here
```{r eval = FALSE, echo=FALSE}
pcoa_iso <- cmdscale(dist_iso_symbioant, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

#outlier_samples <- XX

ordiplot(pcoa_iso, display = 'sites', type = 'text')
barplot (pcoa_iso$eig, names = paste ('PCoA', 1:187), las = 5, ylab = 'eigenvalues')

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.iso <- data.frame(pcoa_iso$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta_iso)# %>% 
 #  mutate(catBleaching = as.factor(catBleaching)) %>% 
 # filter(!(Vial %in% outlier_samples)) 

isoPCA <- MDSxy.iso %>%
  filter(Reef != "NA") %>% 
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1)+ 
#  scale_fill_manual(values = reef_pal) #+
 theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

isoPCA
```

######IGNORE

```{r eval = FALSE, echo=FALSE}

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check <- seqs_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check %>%
  filter(total > 1500)

non_keep <- san_check %>% 
  filter(total < 1500)

#No samples are filtered out

# Filter out the failed samples
seqs_long <- seqs_long %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n <- length(levels(seqs_long$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long$name)

# Read in the profile data
profiles_raw <- read_tsv("profiles.abs.Isopora.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1`:`F4q`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`F4q`)

#Convert to long format 
profiles_long <- profiles_raw %>%
  pivot_longer(`A1`:`F4q`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta_iso) # Add in metadata


# What is the total number of profile-related sequences in each sample?
profiles_sum <- profiles_long %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual <- left_join(profiles_sum, san_check, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta_iso)

# Combine the profiles and non-profile sequences
profile_data <- rbind(profiles_long, residual) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Create palette for profiles (this is a darker palette)
n <- length(levels(profile_data$name))
profile_pal = rainbow(n, s=.6, v=.6)[sample(1:n,n, replace = FALSE)]
names(profile_pal) <- levels(profile_data$name)

# Merge the palettes and replace the non-profile sequences with grey
all_pal <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data <- rbind(seqs_long, profile_data) 

symbioant_iso_all <- all_data
save(symbioant_iso_all, file = "symbioant_iso_all.RData")
```


```{r eval = FALSE, echo=FALSE}
# How many samples per species?
all_data %>%
  distinct(sample_name, Reef) %>%
  group_by(Reef) %>% 
  summarise(total_samples = n())

study_total <- all_data %>% 
   filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  summarise(total_seqs = sum(value)) %>%
  pull(total_seqs)

#9382894 sequences in isopora dataset
```


#By symbiont genus
Please note I was a bit confused by some of the calculations here, so I have hashed them out.
```{r eval = FALSE, echo=FALSE}
all_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C")) %>% 
  summarise(sum = sum(value))
# 8424777	

## not sure this line(X / study_total) * 100 # X Cladocopium proportion of all data.

#Total number of Symbiodinium
all_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "A" | str_detect(name, "_A")) %>% 
  summarise(sum = sum(value)) 
# 10476			total seqs
## Not sure about this calculation (X	 / study_total) * 100 # X Symbiodium


# Total number of Durusdinium sequences
all_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "D" | str_detect(name, "_D")) %>% 
  summarise(sum = sum(value)) 
# 947257	 total reads
```


```{r eval = FALSE, echo=FALSE}
library(tidyverse)

#total type profiles across Isopora 
all_data %>%
  filter(str_detect(name, "p_")) %>%    #profiles start with p_
  group_by(name) %>%
  dplyr:: count() %>%
  dplyr:: arrange(desc(n)) %>%
  ungroup() %>%
  mutate(prop = n/sum(n)) %>%
  mutate(cumulative_sum = cumsum(prop)) %>% 
  print(n=50) #to get a list of the type profiles in isopora

#all_data %>%
  #filter(str_detect(name, "p_")) %>%    #profiles start with p_
  #group_by(name) %>%
  #dplyr:: count() %>%
  #dplyr:: arrange(desc(n)) %>%
  #ungroup() %>%
  #mutate(prop = n/sum(n)) %>%
  #mutate(cumulative_sum = cumsum(prop)) %>% 
  #print(n=50) %>% 
#write.csv(file = "Isopora_ITS2_Type_Profiles.csv")
```


Not sure this line works, not quite sure what I am meant to be doing here though.

```{r eval = FALSE, echo=FALSE}
all_data %>% 
  filter(str_detect(name, "p_")) %>%
  group_by(sample_name) %>% 
  summarise(n = n()) %>% 
 #filter(n == 1)     #150 samples have 1 type profile
 #filter(n == 2)     #23 samples have 2 type profiles 
#filter(n == 3)     #7 samples have 3 profiles 
```

```{r eval = FALSE, echo=FALSE}
all_data %>% 
    filter(str_detect(name, c("p_"))) %>% 
    filter(str_detect(name, c("p_C3k|p_C3"))) %>% 
  summarise(mean = mean(value_rel))      #for relative proportion

#Either C3k or C3 were found as dominant seq in 75.0% of corals sampled 
```


```{r eval = FALSE, echo=FALSE}
#filter out non-profile sequences
seq_data <- all_data %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
```

#2.1 UPGMA tree

```{r eval = FALSE, echo=FALSE}
fasta_iso_symbioant <- read_fasta_df("seqs.isopora.fasta") %>% 
   filter(label %in% seqs_long$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()
```



```{r eval = FALSE, echo=FALSE}
#creating the tree
kdist_iso_symbioant <- fasta_iso_symbioant %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()
```

```{r eval = FALSE, echo=FALSE}
k_tree_iso_symbioant <- kdist_iso_symbioant %>% phangorn::upgma()

k_tree_iso_symbioant

#save(k_tree_iso_symbioant, file = "kdist_iso_symbioant.RData")
load("~/AIMS@JCU/CoralSeaSymbioants/ITS2_Isopora_CS_2024/kdist_iso_symbioant.RData")
```

```{r eval = FALSE, echo=FALSE}
seqs_wide_iso_symbioant <- seq_data %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

head(seqs_wide_iso_symbioant)
```

```{r eval = FALSE, echo=FALSE}
k_unidist_iso_symbioant <- GUniFrac(seqs_wide_iso_symbioant, k_tree_iso_symbioant)   #GUniFrac calculates all the distances 
k_unidist_iso_symbioant <- k_unidist_iso_symbioant$unifracs


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_iso_symbioant <- k_unidist_iso_symbioant[, , "d_0.5"]   
dist_iso_symbioant <- as.dist(du_iso_symbioant, diag = FALSE)

# Cluster the samples
hclust_samps_iso_symbioant <- upgma(du_iso_symbioant)

# Make the sample tree
tree_iso_symbioant <- ggtree(hclust_samps_iso_symbioant, size = 0.2) +
  theme(aspect.ratio = 0.3) + layout_dendrogram()

# Get a sample order from ggtree
iso_sample_order <- tree_iso_symbioant$data %>% filter(isTip == "TRUE") %>%
  arrange(y) %>%
  pull(label)

# Start plotting the composition data
plot_df_iso_symbioant <- all_data %>%
  mutate(sample_name = fct_relevel(sample_name, iso_sample_order))

theme_set(theme_bw())


# find the likely distinguishing seqs in here
test_df <- seq_data %>%
   group_by(name) %>%
   summarise(mean = mean(value_rel), n = n()) %>%
   arrange(desc(n), desc(mean))

# colour them black to check
 test_pal <- all_pal
# test_pal['C21ab'] <- "#000000" 
```

## Fig 2B
```{r eval = FALSE, echo=FALSE}
bar_uni_iso_symbioant <- 
ggplot(plot_df_iso_symbioant, aes(sample_name, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = all_pal, breaks = levels(profile_data$name)) +
scale_colour_manual(values = all_pal, breaks = levels(profile_data$name)) +
geom_hline(yintercept = 1, size = 1) +
guides(fill=guide_legend(ncol=2))


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef. 

tree_iso_symbioant / bar_uni_iso_symbioant
```


```{r eval = FALSE, echo=FALSE}
# Create reef strip
reef_strip <- ggplot(plot_df_iso_symbioant, aes(x = sample_name, y = 1, fill = Reef)) +
  geom_tile() +
  theme_void() +
  theme(legend.position = "top") #+
 # scale_fill_brewer(palette = "Set2")  # or use your own palette

# Now combine the reef strip and your barplot
combined_plot <- reef_strip / bar_uni_iso_symbioant + plot_layout(heights = c(0.1, 1))

# Display it
combined_plot
```


###4.1.3 iso Reef PCoA

It is unclear to me how we determine the outlier samples here
```{r eval = FALSE, echo=FALSE}
pcoa_iso <- cmdscale(dist_iso_symbioant, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

#outlier_samples <- XX

ordiplot(pcoa_iso, display = 'sites', type = 'text')
barplot (pcoa_iso$eig, names = paste ('PCoA', 1:187), las = 5, ylab = 'eigenvalues')

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.iso <- data.frame(pcoa_iso$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta_iso)# %>% 
 #  mutate(catBleaching = as.factor(catBleaching)) %>% 
 # filter(!(Vial %in% outlier_samples)) 

isoPCA <- MDSxy.iso %>%
  filter(Reef != "NA") %>% 
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1)+ 
#  scale_fill_manual(values = reef_pal) #+
 theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

isoPCA
```

## Procrustes Rotation

```{r eval = FALSE, echo=FALSE}
load("~/AIMS@JCU/CoralSeaSymbioants/ITS2_Isopora_CS_2024/Isopora/ind_coords_iso.RData")

iso_seqs_host <- ind_coords_iso %>% 
  mutate("sample_name" = VialID)

#code for defining specific colours per reef for procrustes plots later on
reef_pal2 <- c("#ac1917", "#e54a50", "#b75420", "#ea8553", "#c0982b", "#eec76b", "#768b45", "#a9be77", "#B2DFDB", "#4eaaa6", "#00798C")

reef_names <- c("Elizabeth", "Middleton", "Cato", "Wreck", "Kenn", "Mellish", "Marion","Frederick", "Saumarez", "Madgelaine", "NA")

names(reef_pal2) <- reef_names
```

```{r eval = FALSE, echo=FALSE}
#here is the subset with the data that matches the host data
shared_seqs_iso <- inner_join(iso_seqs_host, seq_data, by = "sample_name")

seq_data %>% 
  distinct(sample_name) %>% 
  nrow()
 #should be 187 in the symbioant

shared_seqs_iso <- shared_seqs_iso %>% 
  select(sample_name)
```

Host tree

```{r eval = FALSE, echo=FALSE}
load("~/AIMS@JCU/CoralSeaSymbioants/ITS2_Isopora_CS_2024/Isopora/iso_gen.RData") #load host data

library(adegenet) #install required package
library(poppr)


# Check your individual names in iso_gen
ind_names_host <- indNames(iso_gen)

# Check the sample names you want to keep
sample_names <- shared_seqs_iso$sample_name

# Subset the genind object to retain only matching individuals
iso_gen_subset <- iso_gen[ind_names_host %in% shared_seqs_iso$sample_name, ]

length(indNames(iso_gen))          # Before 189
length(indNames(iso_gen_subset))   # After 188

#Compute the pairwise distances between multivariate observations; used on raw allele frequencies.
host_shared_dist <- dist(iso_gen_subset, method = "euclidean") #calculate euclidean distance 

# convert the distance matrix to a dist object
host_dist_matrix <- as.dist(host_shared_dist)

#Create a matrix with only common sample names for symbioant
seqs_wide_symbioant <- seq_data %>%
  select(sample_name, name, value) %>%
  filter(sample_name %in% shared_seqs_iso$sample_name) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") #187 samples

#k_tree_iso_symbioant <- kdist_iso_symbioant %>% phangorn::upgma()

load("~/AIMS@JCU/CoralSeaSymbioants/ITS2_Isopora_CS_2024/kdist_iso_symbioant.RData")

k_unidist_symbioant <- GUniFrac(seqs_wide_symbioant, k_tree_iso_symbioant)   #GUniFrac calculates all the distances 
k_unidist_symbioant <- k_unidist_symbioant$unifracs


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_iso_symbioant <- k_unidist_symbioant[, , "d_0.5"]   
dist_iso_symbioant <- as.dist(du_iso_symbioant, diag = FALSE)
```

# Symbioant Tree 



```{r eval = FALSE, echo=FALSE}
#convert host (H) and symbiont (P) distance trees as data matrices
H.dist <- host_dist_matrix %>% as.matrix()
P.dist <- dist_iso_symbioant %>% as.matrix() 
```

```{r eval = FALSE, echo=FALSE}
#must have same number of dimensions 
dim(H.dist)
dim(P.dist) #its really odd that the symbioant has 186 when the code running above has 187 sample names

# Subset to only the samples that are in both datasets
intersect_samples <- intersect(rownames(H.dist), rownames(P.dist))
intersect_samples_col <- intersect(colnames(H.dist), colnames(P.dist)) # The host data set had 189, and the symbioant had 186
P.dist_intersect <- P.dist[intersect_samples, intersect_samples_col]
H.dist_intersect <- H.dist[intersect_samples, intersect_samples_col ]

# Subset to only the samples that are in both datasets
intersect_samples <- intersect(rownames(H.dist_intersect), rownames(P.dist_intersect))
P.dist <- P.dist_intersect
H.dist <- H.dist_intersect

#recheck dimensions - all good 
dim(P.dist)
dim(H.dist)
```

### Perform Paco analysis

```{r eval = FALSE, echo=FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

paco.iso <- procrustes(H.dist, P.dist, symmetric = FALSE)
summary(paco.iso)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#statistics check for residuals 
#paco error chart 
plot(paco.iso, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.iso, kind = 2, type = "text")
```

Number of objects: 186    Number of dimensions: 186 

Procrustes sum of squares:  
 1.563793e+07 
Procrustes root mean squared error: 
 289.9567 
Quantiles of Procrustes errors:
     Min       1Q   Median       3Q      Max 
166.5647 262.5309 276.9388 319.7066 392.3467
*sum of squares here is ridiculous (over 1 million)*

### Isopora procrustes plot

```{r eval = FALSE, echo=FALSE}
#transfer PC coords into dataframe for plotting  
hp.df.iso <- data.frame(rda1=paco.iso$Yrot[,1],
rda2=paco.iso$Yrot[,2],xrda1=paco.iso$X[,1],
xrda2=paco.iso$X[,2]) %>% 
  tibble::rownames_to_column(var = "Vial") 


#filter metadata to just reef
meta.reef <- meta_iso %>% 
  select(sample_name, Reef) %>% 
  rename(sample_name = "Vial")

#left join the metadata to get reef into the dataframe 
hp.df.iso2 <- hp.df.iso %>% left_join(meta.reef)

#create plot 
procrust.iso <- ggplot(hp.df.iso2) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  scale_colour_manual(values = reef_pal2) +
    theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 

save(procrust.iso, file = "procrust.iso.RData")
```

### Test significance 

```{r eval = FALSE, echo=FALSE}
#testing significance 
protest(X = H.dist, Y = P.dist, scores = "sites", permutations = 999)
```

Visualise what is going on without those two massive outliers
```{r eval = FALSE, echo=FALSE}
no_outliers_iso_procreates <- hp.df.iso2 %>% 
  filter(xrda1> -50,
         xrda2>-50)

#create plot 
procrust.iso.2 <- ggplot(no_outliers_iso_procreates) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  scale_colour_manual(values = reef_pal2) +
    theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 
```

